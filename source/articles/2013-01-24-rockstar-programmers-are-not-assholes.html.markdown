--- 
title: "A Rockstar Programmer Isn't the Same Thing as a Smart Asshole"
description: "Assholes shouldn't be hired, even when they can program well. Don't trick yourself into thinking you're hiring a rockstar when really all you've done is hire a smart asshole."
date: 2013-01-24 
popular: true
published: true
tags: hiring
--- 
Everyone is obsessed with hiring and retaining the elusive rockstar programmer, and for good reason. [There's actual data to suggest that yes, some developers are more efficient](http://forums.construx.com/blogs/stevemcc/archive/2011/01/09/origins-of-10x-how-valid-is-the-underlying-research.aspx "developer productivity")... WAY more efficient. Those are the developers we need! How do I get them?

Here's the picture most of us have in our head right now: male, 23 years old, glasses and a t-shirt, a little rough around the edges. Doesn't always work well with others, because they are **one with the code** and of course you'll forgive them for that right? You have to suffer for your art! One can forgive a truly great developer some arrogance, perhaps a little unreliability. After all, this person is brilliant!

So off you go to hire this person, and before you know it you've got a promising candidate. He's a wizards at the latest trendy language, which is all he'll agree to program in. He's been working on a new exclusive mobile search mashup for people with blue eyes, but he decided that the founders 'just didn't get it' and moved on. Uncompromisable standards for the latest technology, in that all technology before it is pretty much outdated and stupid in his mind. Prefers to work alone, and believes that continuous integration means you push code as quickly as possible, because real customers will find the bugs fastest, and "we shouldn't be afraid to roll back". He's created and then abandoned several promising open source frameworks, and by all accounts is an incredibly skilled developer. 

Ok, some of that stuff he told you seems a little off, but no problem, this guy is a rockstar, and maybe a little inflexibility is just the price you pay for genius. So you hire him, and you give him his own office because he demands privacy while he works. And before you know it, changes are happening! He's got the whole team convinced that the latest functional programming language is going to solve all of their problems, because functional languages make it hard to create side effects, and that's really what's killing their productivity. Nobody really knows the new language, and everything else is written in Java, but there's no time like the present to learn, so now everyone is porting the code base to Haskjure, all productivity on new customer features has stopped until we get rid of this old code.  No problem, we'll catch up once we pay down this up front cost. 

Time passes and you hire some new college students, you'd like to put your rock star on the hook for mentoring them, cause he still seems to be the only one who fully understand the new programming language. But he has no time for that, he learned everything on his own, and that's the only way so the new guys should get in there and make it happen. You know what?, he's right. Learning is best done by doing so you tell the new guys to have at it, and a week later, they're still trying to get the unit tests to run on their desktop. You discover it's because they don't have the right credentials, and since their rockstar mentor doesn't have time to help, they've wasted a ton of momentum trying to get bootstrapped. Your fault, you should have remembered.

One day you get a call at 3:30 AM from the engineer oncall. There was a bad software push, and the service has been down for almost an hour now. They rolled back the software, but there's some other issue because that didn't solve the problem. It looks like some of the schema's on the work flow have changed and stuff is stuck. Your rock star made the changes, but he's on a plane to a Haskjure conference. He pushed everything just before he left. Nobody is really sure what the changes are, because nobody was worthy of reviewing his code. All told, the team takes a 3 hour outage, there is public embarrassment for the company, and your leadership chain is justifiably pissed. You're sending out a lot of [when will it be fixed](http://andytroutman.com/articles/2013/01/22/learn-to-write-status-updates.html "How to write status updates") status messages these days. 

Finally, you have the good sense to pull in your rockstar programmer, and tell him that things are going to change. The team has to be trained properly on the system and the technologies they're using, or we're going back to java. There will be more automated testing and community review of code so that people are exposed to changes before they're in production. Everyone needs to be on the same page, or at least reading the same book. 

Your rock star programmer quits in 3 days.

## You hired a smart asshole, not a rockstar

Being smart and opinionated are not bad traits, nor is confidence. But a true "rockstar" (I loath that word by the way) is more than that. The truly great engineers, the mythical 10X engineers, the ones that become principle developers and deliver amazing products - all of them understand the value of others. A rockstar developer isn't just personally productive, they are a productivity magnifier. They sprinkle their smarts throughout the team, and they get others to help them achieve. If you read *[The Myths of Innovation](http://www.amazon.com/gp/product/B0026OR2PE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B0026OR2PE&linkCode=as2&tag=wwwandytroutm-20)* it's clear that humans are obsessed with the hero. We love a one man story of success, but it's a myth. Great things are often achieved through collaboration, and a massive group effort, and as society moves forward, the low hanging fruit has nearly all been picked. Great achievements will increasingly require collected effort. Rockstars know that. 

What I've seen in my best engineers, the ones I would go through great pains to work with, is that while they have their favorite technology, even a recommended technology, they are willing to pick up anything and work with it. There is far too much new and interesting software to write, learning to isolate legacy dependencies so you can move forward is incredibly difficult to do, but the best developers figure out how to make that happen. They figure out how to *[work effectively with legacy code](http://www.amazon.com/gp/product/B005OYHF0A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B005OYHF0A&linkCode=as2&tag=wwwandytroutm-20 "Working Effectively with Legacy Code")*, with a less than ideal tool chain, or with a language that isn't their favorite. Sure they optimize it, they make it better, they don't over-invest in it, but they also don't underestimate the hidden value that's often found in legacy systems. They don't trick themselves into thinking a rewrite will be a flawless version of the existing system.

At the end of the day, the true difference between a rockstar and a false idol is that one of them knows how to deliver for the whole team, and the other one is over-indexed on personal outcomes. Push hard during the interview to figure out which one you're about to hire, one of them isn't worth the price of admission. 
